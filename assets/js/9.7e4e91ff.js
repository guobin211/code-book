(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{359:function(t,a,s){"use strict";s.r(a);var e=s(42),n=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"udp协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#udp协议"}},[t._v("#")]),t._v(" UDP协议")]),t._v(" "),s("blockquote",[s("p",[t._v("User Data Protocol，用户数据报协议")])]),t._v(" "),s("ol",[s("li",[s("p",[t._v("UDP是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。")])]),t._v(" "),s("li",[s("p",[t._v("由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等， 因此一台服务机可同时向多个客户机传输相同的消息。")])]),t._v(" "),s("li",[s("p",[t._v("UDP信息包的标题很短，只有8个字节，相对于TCP的20个字节信息包的额外开销很小。")])]),t._v(" "),s("li",[s("p",[t._v("吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、 源端和终端主机性能的限制。")])]),t._v(" "),s("li",[s("p",[t._v("UDP使用尽最大努力交付，即不保证可靠交付， 因此主机不需要维持复杂的链接状态表（这里面有许多参数）。")])]),t._v(" "),s("li",[s("p",[t._v("UDP是面向报文的。发送方的UDP对应用程序交下来的报文， 在添加首部后就向下交付给IP层。既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。")])])]),t._v(" "),s("h2",{attrs:{id:"udp的包头结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#udp的包头结构"}},[t._v("#")]),t._v(" UDP的包头结构")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("  源端口 16位\n\n  目的端口 16位\n\n  长度 16位\n\n  校验和 16位\n")])])]),s("h2",{attrs:{id:"tcp与udp的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tcp与udp的区别"}},[t._v("#")]),t._v(" TCP与UDP的区别")]),t._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("1、基于连接与无连接\n\n2、对系统资源的要求（TCP较多，UDP少）\n\n3、UDP程序结构较简单\n\n4、流模式与数据报模式\n\n5、TCP保证数据正确性，UDP可能丢包\n\n6、TCP保证数据顺序，UDP不保证\n")])])])])}),[],!1,null,null,null);a.default=n.exports}}]);